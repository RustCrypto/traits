//! Tests for code generated by `signature_derive`

#![cfg(all(feature = "derive", feature = "digest"))]

use digest::{Digest, OutputSizeUser, array::Array};
use hex_literal::hex;
use sha2::Sha256;
use signature::{
    DigestSigner, DigestVerifier, Error, PrehashSignature, SignatureEncoding, Signer, Verifier,
    hazmat::{PrehashSigner, PrehashVerifier},
};

/// Test vector to compute SHA-256 digest of
const INPUT_STRING: &[u8] = b"abc";

/// Expected SHA-256 digest for the input string
const INPUT_STRING_DIGEST: [u8; 32] =
    hex!("ba7816bf 8f01cfea 414140de 5dae2223 b00361a3 96177a9c b410ff61 f20015ad");

type Repr = Array<u8, <Sha256 as OutputSizeUser>::OutputSize>;

/// Dummy signature which just contains a digest output
#[derive(Clone, Debug)]
struct DummySignature(Repr);

impl PrehashSignature for DummySignature {
    type Digest = Sha256;
}

impl SignatureEncoding for DummySignature {
    type Repr = Repr;
}

impl TryFrom<&[u8]> for DummySignature {
    type Error = Error;

    fn try_from(bytes: &[u8]) -> Result<Self, Error> {
        bytes
            .try_into()
            .map(DummySignature)
            .map_err(|_| Error::new())
    }
}

impl From<DummySignature> for Repr {
    fn from(sig: DummySignature) -> Repr {
        sig.0
    }
}

/// Dummy signer which just returns the message digest as a `DummySignature`
#[derive(Signer, DigestSigner, Default)]
struct DummySigner {}

impl PrehashSigner<DummySignature> for DummySigner {
    fn sign_prehash(&self, prehash: &[u8]) -> signature::Result<DummySignature> {
        DummySignature::try_from(prehash)
    }
}

/// Dummy verifier which ensures the `DummySignature` digest matches the
/// expected value.
///
/// Panics (via `assert_eq!`) if the value is not what is expected.
#[derive(Verifier, DigestVerifier, Default)]
struct DummyVerifier {}

impl PrehashVerifier<DummySignature> for DummyVerifier {
    fn verify_prehash(&self, prehash: &[u8], signature: &DummySignature) -> signature::Result<()> {
        assert_eq!(signature.to_bytes().as_slice(), prehash);
        Ok(())
    }
}

#[test]
fn derived_signer_impl() {
    let sig: DummySignature = DummySigner::default().sign(INPUT_STRING);
    assert_eq!(sig.to_bytes().as_slice(), INPUT_STRING_DIGEST)
}

#[test]
fn derived_verifier_impl() {
    let sig: DummySignature = DummySigner::default().sign(INPUT_STRING);
    assert!(DummyVerifier::default().verify(INPUT_STRING, &sig).is_ok());
}
