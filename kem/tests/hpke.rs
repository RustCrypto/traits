/// "Tests" for code generated by `signature_derive`
#[cfg(test)]
mod tests {
    use generic_array::GenericArray;
    use hpke::{
        kem::{Kem as KemTrait, X25519HkdfSha256},
        Deserializable as HpkeDeserializable, Serializable as HpkeSerializable,
    };
    use kem::{
        AuthDecapsulator, Decapsulator, Deserializable, EncappedKey, Encapsulator, Error,
        Serializable,
    };
    use rand::rngs::OsRng;
    use rand_core::{CryptoRng, RngCore};

    // Define the pubkey type and impl the necessary traits. This is a thin wrapper
    #[derive(Clone)]
    struct X25519PublicKey(<X25519HkdfSha256 as KemTrait>::PublicKey);
    impl Serializable for X25519PublicKey {
        type OutputSize =
            <<X25519HkdfSha256 as KemTrait>::PublicKey as hpke::Serializable>::OutputSize;
        fn to_bytes(&self) -> GenericArray<u8, Self::OutputSize> {
            self.0.to_bytes()
        }
    }
    impl core::fmt::Debug for X25519PublicKey {
        // The underlying pubkey doesn't impl Debug. That'll be fixed eventually
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            write!(f, "HPKE-X25519HkdfSha256 public key")
        }
    }

    // Define the encapsulated key type and impl the necessary traits. Since authenticated and
    // unauthenticated DHKEMs have the same encapped key type, this will support both types of
    // algorithms. In practice, one should use types to distinguish between the two. But this is
    // just test code, so whatever.
    struct X25519Ek(<X25519HkdfSha256 as KemTrait>::EncappedKey);
    impl Serializable for X25519Ek {
        type OutputSize =
            <<X25519HkdfSha256 as KemTrait>::EncappedKey as HpkeSerializable>::OutputSize;
        fn to_bytes(&self) -> GenericArray<u8, Self::OutputSize> {
            self.0.to_bytes()
        }
    }
    impl Deserializable for X25519Ek {
        fn from_bytes(bytes: &[u8]) -> Result<Self, Error> {
            <<X25519HkdfSha256 as KemTrait>::EncappedKey as HpkeDeserializable>::from_bytes(bytes)
                .map(X25519Ek)
                .map_err(|_| Error)
        }
    }
    impl EncappedKey for X25519Ek {
        type NSecret = <X25519HkdfSha256 as KemTrait>::NSecret;
        type PublicKey = X25519PublicKey;
    }
    impl core::fmt::Debug for X25519Ek {
        // The underlying encapped key doesn't impl Debug. That'll be fixed eventually
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            write!(f, "HPKE-X25519HkdfSha256 encapped key")
        }
    }

    // Define some convenience types
    type X25519PrivateKey = <X25519HkdfSha256 as KemTrait>::PrivateKey;
    type SharedSecret = GenericArray<u8, <X25519Ek as EncappedKey>::NSecret>;

    // Define an authenticated encapsulator. To authenticate, we need a full sender keypair.
    struct X25519AuthEncap(X25519PrivateKey, X25519PublicKey);
    impl Encapsulator<X25519Ek> for X25519AuthEncap {
        fn try_encap<R: RngCore + CryptoRng>(
            &self,
            csprng: &mut R,
            recip_pubkey: &X25519PublicKey,
        ) -> Result<(X25519Ek, SharedSecret), Error> {
            <X25519HkdfSha256 as KemTrait>::encap(
                &recip_pubkey.0,
                Some((&self.0, &(self.1).0)),
                csprng,
            )
            .map(|(ss, ek)| (X25519Ek(ek), ss.0))
            .map_err(|_| Error)
        }
    }

    // Define an unauthenticated encapsulator. This doesn't need any state at all.
    struct X25519Encap;
    impl Encapsulator<X25519Ek> for X25519Encap {
        fn try_encap<R: RngCore + CryptoRng>(
            &self,
            csprng: &mut R,
            recip_pubkey: &X25519PublicKey,
        ) -> Result<(X25519Ek, SharedSecret), Error> {
            <X25519HkdfSha256 as KemTrait>::encap(&recip_pubkey.0, None, csprng)
                .map(|(ss, ek)| (X25519Ek(ek), ss.0))
                .map_err(|_| Error)
        }
    }

    // Define an decapsulator. Since authenticated and unauthenticated encapped keys are
    // represented by the same type (which, outside of testing, should not be the case), this can
    // do both auth'd and unauth'd decapsulation.
    struct X25519Decap(X25519PrivateKey);
    impl Decapsulator<X25519Ek> for X25519Decap {
        fn try_decap(&self, encapped_key: &X25519Ek) -> Result<SharedSecret, Error> {
            <X25519HkdfSha256 as KemTrait>::decap(&self.0, None, &encapped_key.0)
                .map(|ss| ss.0)
                .map_err(|_| Error)
        }
    }
    impl AuthDecapsulator<X25519Ek> for X25519Decap {
        fn try_auth_decap(
            &self,
            encapped_key: &X25519Ek,
            sender_pubkey: &X25519PublicKey,
        ) -> Result<SharedSecret, Error> {
            <X25519HkdfSha256 as KemTrait>::decap(&self.0, Some(&sender_pubkey.0), &encapped_key.0)
                .map(|ss| ss.0)
                .map_err(|_| Error)
        }
    }

    // A simple wrapper around the keypair generation function
    fn gen_keypair<R: RngCore + CryptoRng>(csprng: &mut R) -> (X25519PrivateKey, X25519PublicKey) {
        let (sk, pk) = X25519HkdfSha256::gen_keypair(csprng);
        let wrapped_pk = X25519PublicKey(pk);

        (sk, wrapped_pk)
    }

    #[test]
    fn test_hpke() {
        let mut rng = OsRng;

        // Make a sender and recipient keypair
        let (sk_sender, pk_sender) = gen_keypair(&mut rng);
        let (sk_recip, pk_recip) = gen_keypair(&mut rng);

        // Try an unauthed encap first. Check that the derived shared secrets are equal
        let encapper = X25519Encap;
        let decapper = X25519Decap(sk_recip);
        let (ek, ss1) = encapper.try_encap(&mut rng, &pk_recip).unwrap();
        let ss2 = decapper.try_decap(&ek).unwrap();
        assert_eq!(ss1, ss2);

        // Now do an authenticated encap
        let encapper = X25519AuthEncap(sk_sender, pk_sender.clone());
        let (ek, ss1) = encapper.try_encap(&mut rng, &pk_recip).unwrap();
        let ss2 = decapper.try_auth_decap(&ek, &pk_sender).unwrap();
        assert_eq!(ss1, ss2);

        // Now do an invalid authenticated encap, where the sender uses the wrong private key. This
        // should produce unequal shared secrets.
        let (rand_sk, _) = gen_keypair(&mut rng);
        let encapper = X25519AuthEncap(rand_sk, pk_sender.clone());
        let (ek, ss1) = encapper.try_encap(&mut rng, &pk_recip).unwrap();
        let ss2 = decapper.try_auth_decap(&ek, &pk_sender).unwrap();
        assert_ne!(ss1, ss2);
    }
}
